# SPDX-FileCopyrightText: (c) 2025 Tenstorrent AI ULC
#
# SPDX-License-Identifier: Apache-2.0

import xml.etree.ElementTree as ET
import ast
import pytest
import subprocess
import re

crashsafe_suffix = "_crashsafe.xml"
achieved_depth_mapping = {
    "FAILED_FE": 0,
    "STABLEHLO": 1,
    "TTNN_IR": 2,
    "EXECUTE": 3,
    "PASSED": 4,
}


def get_achieved_compile_depths(xml_file):
    try:
        # Parse the XML file
        tree = ET.parse(xml_file)
        root = tree.getroot()

        # This function assumes only one model result is present in each XML fil
        # Find all <property> elements with name="achieved_compile_depth"
        compile_depths = [
            prop.attrib["value"]
            for prop in root.findall(
                ".//property[@name='achieved_compile_depth']"
            )  # xpath expr
        ]

        # Return the list of values or "FAILED_FE" if none are found
        # return compile_depths if compile_depths else ["FAILED_FE"]
        if len(compile_depths) == 0:
            return ["FAILED_FE"]

        return compile_depths

    except ET.ParseError as e:
        print(f"Error parsing XML: {e}")
        return ["FAILED_FE"]


def get_max_achieved_compile_depth(xml_file):

    # reverse_compile_depth_mapping = {v: k for k, v in achieved_depth_mapping.items()}
    # numeric_depths = [achieved_depth_mapping.get(depth, 0) for depth in compile_depths]

    compile_depths = get_achieved_compile_depths(xml_file)

    if "PASSED" in compile_depths:
        return "PASSED"
    elif "EXECUTE" in compile_depths:
        return "EXECUTE"

    # Due to graph breaks, only capture the last marked achieved depth if only 1 and 2 are present and alternating
    return compile_depths[-1]


def check_valid_xml(xml_file):
    required_property_names = ["frontend", "model_name", "owner", "group"]

    try:
        # Parse the XML file
        tree = ET.parse(xml_file)
        root = tree.getroot()

        # Check if each required property exists
        for property_name in required_property_names:
            xpath = f".//property[@name='{property_name}']"
            if root.find(xpath) is None:
                raise AssertionError(
                    f"Property with name='{property_name}' does not exist in the XML. This XML file is probably empty, and records a skipped test."
                )

    except ET.ParseError as e:
        print(f"Error parsing XML: {e}")
    except AssertionError as e:
        print(f"Assertion failed: {e}")


def inject_param_into_tags(xml_file, tag_name, tag_value):
    tree = ET.parse(xml_file)
    root = tree.getroot()

    # Find the <property> element with name="tags"
    tags_property = root.find(".//property[@name='tags']")
    if tags_property is not None:
        # Parse the existing tags value as a dictionary
        tags_dict = ast.literal_eval(tags_property.attrib["value"])
    else:
        # Create a new tags dictionary if it doesn't exist
        tags_dict = {}

    # Inject the max achieved compile depth into the tags dictionary
    # pack model_name and frontend from properties into tags (overwriting is ok)
    tags_dict["model_name"] = root.find(".//property[@name='model_name']").attrib[
        "value"
    ]
    tags_dict["frontend"] = root.find(".//property[@name='frontend']").attrib["value"]

    tags_dict[tag_name] = tag_value
    tags_dict[
        "crashsafe"
    ] = "This XML file was generated by the crashsafe XML writer (tt-torch gh issue #443). Test time and passing status may be inaccurate."

    # Update or create the <property> element for tags
    if tags_property is not None:
        tags_property.set("value", str(tags_dict))
    else:
        # Find the <properties> element to add the new <property>
        properties_element = root.find(".//properties")
        ET.SubElement(properties_element, "property", name="tags", value=str(tags_dict))

    # Write the updated XML back to the file
    tree.write(xml_file, encoding="utf-8", xml_declaration=True)


def remap_max_achieved_compile_depth_to_bringup_status(maxdepth):
    translation_table = {
        "FAILED_FE": "FAILED_FE_COMPILATION",
        "STABLEHLO": "FAILED_TTMLIR_COMPILATION",
        "TTNN_IR": "FAILED_RUNTIME",
        "EXECUTE": "INCORRECT_RESULT",
        "PASSED": "PASSED",
    }
    return translation_table.get(maxdepth, "UNKNOWN_BRINGUP_STATUS")


def rewrite_crashsafe_xml(xml_file):
    check_valid_xml(xml_file)
    max_achieved_compile_depth = get_max_achieved_compile_depth(xml_file)
    inject_param_into_tags(
        xml_file, "max_achieved_compile_depth", max_achieved_compile_depth
    )

    bringup_status = remap_max_achieved_compile_depth_to_bringup_status(
        max_achieved_compile_depth
    )
    inject_param_into_tags(xml_file, "bringup_status", bringup_status)
